{
  "name": "proto",
  "version": "1.0.17",
  "main": "proto.js",
  "description": "A prototype-based inheritance library that makes it easy to create objects and inheritance hierarchies without losing the power of javascript's prototype system.",
  "keywords": [
    "class",
    "inheritance",
    "prototype",
    "javascript",
    "superclass",
    "parent",
    "child",
    "inherit"
  ],
  "dependencies": {},
  "devDependencies": {
    "deadunit": "",
    "build-modules": "2.0.3"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/fresheneesz/proto"
  },
  "scripts": {},
  "readme": "\r\n`proto`\r\n=====\r\n\r\nA prototype-based inheritance/class library that makes it easy to create objects and inheritance hierarchies without losing the\r\npower of javascript's prototype system.\r\n\r\nWhy Use proto?\r\n==============\r\n* `proto` plays nice - you can use proto to inherit from any object, even if it was created with a different inheritance library!\r\n* `instanceof` works with `proto` classes\r\n* constructors are inheritable\r\n* non-objects can be returned from a constructor (even `undefined`)!\r\n* easy access to an object's superclass\r\n* you can give your classes dynamic names\r\n* you don't hafta use the `new` operator\r\n* native objects work with `proto`. `proto` properly* creates classes that inherit from native objects - even all the `Error` types. *_Inheriting certain native javascript objects has some limitations (see below)_\r\n* [`prototype` and `constructor` properties][javascriptFunctionProperties] are propertly set\r\n* `proto` doesn't use `Object.create` so it should work with older browsers ( *testers welcome!* )\r\n* `proto` is small: ( __1.74 KB minified and in UMD format__ )\r\n* `proto` is lightweight. It doesn't attempt to emulate class-based languages or create any fancy features you probably don't actually need (interfaces, abstract classes, etc)\r\n* Its one of the fastest inheritance libraries: [method calls](http://jsperf.com/js-inheritance-performance-method-calls), [instance creation](http://jsperf.com/js-inheritance-instances)\r\n\r\n[javascriptFunctionProperties]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype\r\n\r\nExample\r\n=======\r\n\r\n```javascript\r\nvar Person = proto(function() {       // prototype builder\r\n    this.init = function(legs, arms) {      // constructor\r\n        this.legs = legs\r\n        this.arms = arms\r\n    }\r\n\r\n    this.getCaughtInBearTrap = function() { // instance method\r\n        this.legs -= 1\r\n    }\r\n    this.limbs = function() {\r\n        return this.arms + this.legs\r\n    }\r\n    Object.defineProperty(this, 'limbs', { // getters (and setters, etc) can be set right on the prototype!\r\n        get: function() {\r\n            return this.arms + this.legs\r\n        }\r\n    })\r\n\r\n})\r\n\r\nvar Girl = proto(Person, function() {       // inheritance\r\n    this.haveBaby = function() {\r\n        return Person(2,2)\r\n    }\r\n})\r\n\r\nvar g = Girl(2,2)                          // instantiation\r\ng.getCaughtInBearTrap()\r\nconsole.log(\"Girl has \"+g.limbs+\" limbs\")\r\nconsole.log(\": (\")\r\n\r\nvar newPerson = g.haveBaby()\r\nconsole.log(\"New person has\" +newPerson.limbs+\" limbs : )\")\r\n ```\r\n\r\n\r\nInstall\r\n=======\r\n\r\n```\r\nnpm install proto\r\n```\r\n\r\n\r\nUsage\r\n=====\r\n\r\nAccessing proto:\r\n```javascript\r\n// node.js\r\nvar proto = require('proto')\r\n\r\n// amd\r\nrequire.config({paths: {proto: '../generatedBuilds/proto.umd.js'}})\r\nrequire(['proto'], function(proto) { /* your code */ })\r\n\r\n// global variable\r\n<script src=\"proto.umd.js\"></script>\r\nproto; // proto.umd.js can define proto globally if you really\r\n       //   want to shun module-based design\r\n```\r\n\r\nUsing proto:\r\n```javascript\r\nvar Parent = proto(function() {\r\n    this; // points to the prototype, so set methods and static properties on this\r\n\r\n    // the name property has an impact on how proto classes are displayed in dev tools\r\n    this.name = 'MyProto'; // set a name for your proto class\r\n\r\n    this.init = function(v) {   // constructor\r\n        this; // inside methods, 'this' references the instance\r\n\r\n        if(v > 0) {\r\n            this.x = v                // you can normally access the object with this inside methods\r\n        } else if(v !== undefined) {\r\n\t\t\treturn true\t              // you can return non-object values\r\n\t\t} else {\r\n\t\t\treturn proto.undefined    // return undefined by using a special constructor return value\r\n\t\t}\r\n    }\r\n\r\n    this.anythingElse = 5   // static properties can be accessed by the class and the instance\r\n\r\n    // getters and setters (enumerable makes it available statically too! Ie)\r\n    Object.defineProperty(this, 'moose', {\r\n        enumerable: true,\r\n        get: function() {\r\n            return 5\r\n        },\r\n        set: function() {\r\n            console.log(\"just kidding, i'm not setting anything!\")\r\n        }\r\n    })\r\n\r\n\t// private functions don't have access to the correct 'this', so pass it in\r\n    var privateFn = function(that, arg1, etc) {\r\n        that.x = arg1 + etc\r\n    }\r\n\r\n    this.doSomething = function() {\r\n        privateFn(this, this.x, 1)\r\n    }\r\n})\r\n\r\nParent.name;  // the name property can be accessed directly from the returned proto class object\r\n\r\n// you can inherit from any object!\r\n// the resulting object factory will generate instances inheriting from:\r\n    // [if you inherit from]\r\n        // [a function]: that function's prototype\r\n        // [anything else]: that object itself\r\nvar Child = proto(Parent, function(superclass) {\r\n    this.init = function() {\r\n        superclass.init.call(this, arguments) // super-class method call\r\n        // superclass.prototype.init.call(this, arguments) // remember that you probably need to access superclass.prototype for parents that aren't proto objects\r\n        this.r = 10\r\n    }\r\n\r\n\t// create static methods just like instance methods - you can access them from the constructor\r\n    this.staticMethod = function(x) {\r\n        return this.constructor(x+12)        // uses its own constructor to create a Child object\r\n    }\r\n})\r\n\r\nvar object = Child(1)                // instantiation\r\nobject.doSomething()                 // method call (as usual)\r\nvar object2 = Child.staticMethod(1)  // static method call\r\n\r\nChild.parent === Parent; // the 'parent' property on the will point to the proto class's parent\r\n\r\n ```\r\n\r\nCreating a custom Error object:\r\n```javascript\r\nvar CustomError = proto(Error, function(superclass) {\r\n    this.name = 'CustomError'\r\n\r\n    this.init = function(msg, properties) {\r\n        superclass.call(this, msg)\r\n        for(var n in properties) {\r\n            this[n] = properties[n]\r\n        }\r\n    }\r\n})\r\n```\r\n\r\nLimitations of `proto`\r\n=============================================\r\n* Inheriting from `Error` and other exception types doesn't automatically set a correct `name` property, so you need to set it as a static properly \"manually\".\r\n* Objects inheriting from `String` can't use the `toString` method. \r\n* Inheriting from `Array` doesn't work.\r\n* Inheriting from `RegExp` doesn't work either (the results can't use the `test` or `match` methods).\r\n* You can't properly access any non-writable properties of a function from the returned proto-object factory though the properties will work correctly on instances. This includes: `name`, `length`, `arguments`, and `caller`.\r\n* Some properties are read-only and so can't be reset on the prototype object. An example is `name` on firefox.\r\n\r\nTodo\r\n====\r\n* Browser testing\r\n * Chrome [x]\r\n * Firefox [x]\r\n * Safari [x]\r\n * IE11 [ ]\r\n * IE10 [ ]\r\n * IE9 [ ]\r\n * IE8 [ ]\r\n * Opera [ ]\r\n\r\n* performance improvements\r\n    * Combine ProtoObjectFactory with the NamedFunction so you remove a function call there\r\n    * memoize whether the class has 'init' or not (to remove one branch from ProtoObjectFactory)\r\n\r\n* Consider creating a Proto2 that focuses on further performance improvements:\r\n    * Requires the use of 'new'\r\n    * Maybe sacrifices dynamic prototypes (that change after constructor creation) to get rid of the prototype chain walking (and just merges in functions)\r\n\r\nHow to Contribute!\r\n============\r\n\r\nAnything helps:\r\n\r\n* Creating issues (aka tickets/bugs/etc). Please feel free to use issues to report bugs, request features, and discuss changes\r\n* Updating the documentation: ie this readme file. Be bold! Help create amazing documentation!\r\n* Submitting pull requests.\r\n\r\nHow to submit pull requests:\r\n\r\n1. Please create an issue and get my input before spending too much time creating a feature. Work with me to ensure your feature or addition is optimal and fits with the purpose of the project.\r\n2. Fork the repository\r\n3. clone your forked repo onto your machine and run `npm install` at its root\r\n4. If you're gonna work on multiple separate things, its best to create a separate branch for each of them\r\n5. edit!\r\n6. If it's a code change, please add to the unit tests (at test/protoTest.js) to verify that your change\r\n7. When you're done, run the unit tests and ensure they all pass\r\n8. Commit and push your changes\r\n9. Submit a pull request: https://help.github.com/articles/creating-a-pull-request\r\n\r\nContributors\r\n============\r\n* Special thanks to [jayferd][jayferd], since I got most of the unit tests for `proto` from [his `pjs` project][pjs].\r\n\r\n\r\n[jayferd]: https://github.com/jayferd\r\n[pjs]: https://github.com/jayferd/pjs\r\n\r\nChange Log\r\n=========\r\n\r\n* 1.0.17 - Correcting distribution\r\n* 1.0.16 - optimizing instance creation - made it about 3 times as fast! Now its one of the fastest inheritance libraries!\r\n* 1.0.15 - changing to using webpack to make UMD packages\r\n* 1.0.14 - fixing the name property so if there is no name, 'undefined' doesn't become the functions name\r\n* 1.0.13 - adding a 'parent' property on the returned proto class\r\n* 1.0.12 - making the constructor's name property settable (via `this.name` in the class construction function - the function passed to proto)\r\n* 1.0.11 - adding the ability to access getters and setters correctly statically\r\n* 1.0.10 - making the stack property a getter (like it is in native error objects)\r\n* 1.0.8 - if a static property can't be written (because it's read only or for some other reason throws an exception when being set), it will now silently not set, instead of throwing an exception\r\n* 1.0.7 - getting rid of useless line in stack trace\r\n* 1.0.6 - fixing custom error name in stacktraces\r\n* 1.0.5 - fixing github dependencies\r\n\r\nLicense\r\n=======\r\nReleased under the MIT license: http://opensource.org/licenses/MIT",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/fresheneesz/proto/issues"
  },
  "homepage": "https://github.com/fresheneesz/proto",
  "_id": "proto@1.0.17",
  "dist": {
    "shasum": "d823ceadcbc75bd1fc370db85cdd089c561d027e"
  },
  "_from": "https://registry.npmjs.org/proto/-/proto-1.0.17.tgz",
  "_resolved": "https://registry.npmjs.org/proto/-/proto-1.0.17.tgz"
}
