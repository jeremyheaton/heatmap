// some functionality that is needed by Block.js but is related to styling (some things are also needed by Style.js)

var HashMap = require("hashmap")

var Style = require("./Style")
var utils = require('./utils')

exports.defaultStyleMap = new HashMap() // maps from a proto class to its computed default style

// propogates a style-set change to a set of components
    // styleMap should be a *copy* of a Style's componentStyleMap property (because it will be modified)
var propogateStyleSet = exports.propogateStyleSet = function (components, styleMap) {
    for(var n=0; n<components.length; n++) {
        var c = components[n]

        // object inherits style if its in the styleSet and if it doesn't have an explicitly set style
        if(c._style === undefined) {
            if(styleMap === undefined) {
                setCurrentStyle(c, undefined)
            } else {
                var styleFromMap = getStyleForComponent(styleMap, c)
                if(styleFromMap !== undefined) {
                    setCurrentStyle(c, styleFromMap)
                }
            }
        }

        // set the computed style set
        var mainStyle; // the style directly given to a component, either its `style` property, or its inherited style
        if(c._style !== undefined) {
            mainStyle = c._style.get(c)
        } else if(styleMap !== undefined) {
            mainStyle = getStyleForComponent(styleMap, c)
            if(mainStyle !== undefined) {
                mainStyle = mainStyle.get(c) // get the specific style (taking into account any label)
            }
        }

        if(mainStyle !== undefined) {
            if(styleMap !== undefined) {
                c.computedStyleMap = styleMapConjunction(styleMap, mainStyle.componentStyleMap)
            } else {
                c.computedStyleMap = mainStyle.componentStyleMap
            }
        } else {
            c.computedStyleMap = styleMap
        }

        propogateStyleSet(c.children, c.computedStyleMap)
    }
}

// gets the right style from the styleMap
// takes the component's inheritance tree into account (relies on the block.constructor.parent property)
var getStyleForComponent = exports.getStyleForComponent = function (styleMap, block) {
    var constructor = block.constructor
    while(constructor !== undefined) {
        var style = styleMap[constructor.name]
        if(style !== undefined) {
            return style
        } else {
            constructor = constructor.parent
        }
    }
}

// returns the conjunction of two style maps
// gets it from the computedStyles cache if its already in there
var styleMapConjunction = exports.styleMapConjunction = function (secondaryStyleMap, primaryStyleMap) {
    var cachedStyleMap = Style.computedStyles.get([secondaryStyleMap, primaryStyleMap])
    if(cachedStyleMap === undefined) {
        cachedStyleMap = utils.objectConjunction(secondaryStyleMap, primaryStyleMap)
        Style.computedStyles.set([secondaryStyleMap, primaryStyleMap], cachedStyleMap)
    }

    return cachedStyleMap
}

// takes labels into account
var setCurrentStyle = exports.setCurrentStyle = function (component, style) {
    if(style === component.currentStyle) return; // do nothing

    if(style !== undefined)
        var specificStyle = style.get(component)
    else
        var specificStyle = style

    setStyleClass(component, specificStyle)
    applyStyleKillFunction(component)
    component.currentStyle = specificStyle
    applyStyleSetupFunction(component, specificStyle)
    applyStateHandler(component, specificStyle)
}


exports.createDefaultBlockStyle = function (that) {
    if(that.defaultStyle !== undefined) {
        validateDefaultStyle(that.defaultStyle)
    }

    // get list of default styles
    var defaultStyles = []
    var nextConstructor = that.constructor
    while(nextConstructor !== undefined) {
        if(nextConstructor.defaultStyle !== undefined) {
            defaultStyles.push(nextConstructor.defaultStyle)
        }
        nextConstructor = nextConstructor.parent
    }

    // generate merged default style
    var defaultStyleSet = {}
    defaultStyles.reverse().forEach(function(style) {
        for(var k in style.styleDefinitions) {
            utils.merge(defaultStyleSet, style.styleDefinitions[k])
            break; // just do first key (shouldn't be more than one key, because only simple stylings are allowed for default styles)
        }

    })

    if(Object.keys(defaultStyleSet).length > 0)
        var defaultBlockStyle = Style(defaultStyleSet, {default:true})
    else
        var defaultBlockStyle = false // no special default

    exports.defaultStyleMap.set(that.constructor, defaultBlockStyle)
    return defaultBlockStyle
}


// applies setup appropriately
function applyStyleSetupFunction(component, style) {
    if(style !== undefined && style.setup !== undefined) {
        component._styleSetupObject = style.setup(component) // call setup on the component
    } else {
        component._styleSetupObject = undefined
    }
}
// applies kill appropriately
function applyStyleKillFunction(component) {
    var currentStyle = component.currentStyle
    if(currentStyle !== undefined && currentStyle.setup !== undefined) {
        if(currentStyle.kill === undefined)
            throw new Error('style has been unset but does not have a "kill" function to undo its "setup" function')

        currentStyle.kill(component, component._styleSetupObject)
    }
}

// initializes and sets up state-change handler
function applyStateHandler(component, style) {
    if(style !== undefined && style.stateHandler !== undefined) {
        // todo: using setCurrentStyle is a stopgap until I can implement better style application for $state and pseudoclasses (which probably will require a rewrite of much of the style logic)
        setCurrentStyle(component, style.stateHandler(component.state.subject))
        component.state.on('change', function() {
            setCurrentStyle(component, style.stateHandler(component.state.subject))
        })
    }
}

// sets the style, replacing one if one already exists
function setStyleClass(component, style) {
    var currentStyle = component.currentStyle
    if(currentStyle !== undefined) {
        component.domNode.className = component.domNode.className.replace(new RegExp(" ?\\b"+currentStyle.className+"\\b"),'') // remove the previous css class
    }
    if(style !== undefined) {
        component.domNode.className = style.className+' '+component.domNode.className.trim() // note that the order of classes doesn't matter
    }
}

function validateDefaultStyle(defaultStyle) {
    if(!(defaultStyle instanceof Style)) {
        throw new Error("defaultStyle property must be a Style object")
    } else if(
        defaultStyle.setup !== undefined || defaultStyle.kill !== undefined || defaultStyle.stateHandler !== undefined ||
        Object.keys(defaultStyle.componentStyleMap).length > 0 || Object.keys(defaultStyle.labelStyleMap).length > 0 /*||
        Object.keys(defaultStyle.pseudoClassStyles).length > 0*/
    ) {
        throw new Error("A Block's defaultStyle can only contain basic css stylings, no Block, label, or pseudoclass stylings, nor run/kill javascript")
    }
}